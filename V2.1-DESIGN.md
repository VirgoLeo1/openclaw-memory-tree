# 🌳 Memory Tree v2.1: 语义复活 (Semantic Resurrection)

> "归档不等于死亡，记忆只是暂时休眠。"

## 1. 背景与目标
在 v2.0 中，我们实现了自动剪枝（低热度节点归档）。但存在一个隐患：**低频高价值记忆**可能因为长时间未被访问而被永久遗忘。
v2.1 的目标是引入**语义复活机制**，让归档的记忆能在特定上下文中被“唤醒”。

## 2. 核心概念

### 2.1 记忆指纹 (Memory Fingerprint)
*   **定义**: 每个归档节点的唯一语义标识。
*   **实现方案**:
    *   *当前 (v2.1-alpha)*: 使用**关键词哈希**或**简化向量**模拟。
    *   *未来 (v2.1-beta)*: 集成 `nomic-embed-text` 或 `sentence-transformers` 生成真实嵌入向量。

### 2.2 语义相似度 (Semantic Similarity)
*   **定义**: 衡量当前上下文与归档记忆的相关程度。
*   **算法**: 余弦相似度 (Cosine Similarity)。
*   **阈值**: `0.85` (可配置)。高于此值视为“强相关”。

### 2.3 自动复活 (Auto-Resurrection)
*   **触发条件**: 检测到强相关归档节点。
*   **动作**:
    1.  将归档文件移回主目录。
    2.  热度恢复至 `HEAT_MEDIUM` (默认 40)。
    3.  发送通知："🔥 记忆复活：发现与当前上下文高度相关的归档记忆 [xxx]，已自动激活。"

## 3. 流程设计

### 3.1 归档时 (Prune Phase)
```text
节点热度 < 10 且 > 7 天
  ↓
生成记忆指纹 (Fingerprint)
  ↓
保存指纹至 archive_metadata.json
  ↓
移动文件至 archive/ 目录
```

### 3.2 运行时 (Runtime Phase)
```text
新对话/事件发生
  ↓
提取当前上下文关键词/向量
  ↓
遍历 archive_metadata.json 计算相似度
  ↓
相似度 > 0.85 ?
  ├─ 是 → 触发复活逻辑 (移回 + 热度恢复 + 通知)
  └─ 否 → 保持归档
```

## 4. 待办事项 (TODO)
- [x] 设计文档与架构规划。
- [ ] **集成真实嵌入模型** (如 nomic-embed-text) 替换当前的模拟逻辑。
- [ ] 实现异步队列，避免复活检测阻塞主线程。
- [ ] 增加“复活历史”日志，记录哪些记忆被唤醒过。

## 5. 版本历史
- **v2.1-alpha**: 核心逻辑框架，模拟指纹与相似度计算。
- **v2.1-beta** (规划中): 集成真实向量模型，优化性能。
